<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R/V Packard Blog</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .data-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .data-panel h2 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.5rem;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }

        .data-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid #f1f5f9;
        }

        .data-item:last-child {
            border-bottom: none;
        }

        .data-label {
            font-weight: 600;
            color: #2d3748;
            font-size: 1.1rem;
        }

        .data-value {
            font-family: 'Courier New', monospace;
            background: #f7fafc;
            padding: 8px 12px;
            border-radius: 6px;
            color: #2d3748;
            font-size: 1rem;
        }

        .map-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .map-container h2 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.5rem;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }

        #map {
            height: 400px;
            border-radius: 10px;
            border: 2px solid #e2e8f0;
        }

        .status-bar {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            text-align: center;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
        }

        .status-online {
            background: #c6f6d5;
            color: #22543d;
        }

        .status-offline {
            background: #fed7d7;
            color: #742a2a;
        }

        .status-loading {
            background: #fef5e7;
            color: #744210;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-online .status-dot {
            background: #38a169;
        }

        .status-offline .status-dot {
            background: #e53e3e;
        }

        .status-loading .status-dot {
            background: #d69e2e;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .last-updated {
            margin-top: 15px;
            color: #718096;
            font-size: 0.9rem;
        }

        /* Vessel marker styling */
        .vessel-marker {
            background: transparent;
            border: none;
            font-size: 24px;
            text-align: center;
            line-height: 1;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .container {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>R/V Packard Location Tracker</h1>
            <p>Real-time vessel position monitoring</p>
        </div>

        <div class="main-content">
            <div class="data-panel">
                <h2>Current Position</h2>
                <div class="data-item">
                    <span class="data-label">Latitude:</span>
                    <span class="data-value" id="latitude">Loading...</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Longitude:</span>
                    <span class="data-value" id="longitude">Loading...</span>
                </div>
                <div class="data-item">
                    <span class="data-label">Timestamp (UTC):</span>
                    <span class="data-value" id="timestamp">Loading...</span>
                </div>
            </div>

            <div class="map-container">
                <h2>Location Map</h2>
                <div id="map"></div>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-indicator status-loading" id="statusIndicator">
                <div class="status-dot"></div>
                <span id="statusText">Connecting...</span>
            </div>
            <div class="last-updated" id="lastUpdated"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Global variables
        let map;
        let vesselMarker;
        let trackPolyline;
        let lastUpdateTime = null;
        let trackData = []; // Store last 36 points

        // Initialize the map
        function initMap() {
            map = L.map('map').setView([36.8, -121.8], 6);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);
        }

        // Convert unix timestamp to ISO 8601 UTC format
        function unixToISO8601(unixTimestamp) {
            const date = new Date(unixTimestamp * 1000);
            return date.toISOString();
        }

        // Update status indicator
        function updateStatus(status, message) {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            
            indicator.className = `status-indicator status-${status}`;
            text.textContent = message;
        }

        // Update last updated time
        function updateLastUpdated() {
            const now = new Date();
            const timeString = now.toLocaleString('en-US', {
                timeZone: 'UTC',
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                timeZoneName: 'short'
            });
            document.getElementById('lastUpdated').textContent = `Last updated: ${timeString}`;
        }

        // Fetch and parse vessel data
        async function fetchVesselData() {
            try {
                updateStatus('loading', 'Fetching data...');
                
                // Use CORS proxy to bypass cross-origin restrictions
                const proxyUrl = 'https://api.allorigins.win/raw?url=';
                const targetUrl = 'https://www3.mbari.org/lobo/Data/GliderVizData/rvpackard.txt';
                const fullUrl = proxyUrl + encodeURIComponent(targetUrl);
                
                console.log('Fetching from:', fullUrl); // Debug log
                
                const response = await fetch(fullUrl);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const csvText = await response.text();
                console.log('Raw CSV data:', csvText.substring(0, 200) + '...'); // Debug log
                
                const lines = csvText.trim().split('\n');
                
                if (lines.length < 2) {
                    throw new Error('No data available');
                }
                
                // Skip header line and get all data lines
                const dataLines = lines.slice(1).filter(line => line.trim() !== '');
                
                if (dataLines.length === 0) {
                    throw new Error('No data lines found');
                }
                
                // Get the last 36 points (or all available if less than 36)
                const recentPoints = dataLines.slice(-36);
                console.log(`Processing ${recentPoints.length} data points`); // Debug log
                
                // Parse all recent points
                const parsedPoints = [];
                for (const line of recentPoints) {
                    const parts = line.split(',');
                    
                    if (parts.length !== 3) {
                        console.warn(`Skipping invalid line: ${line}`);
                        continue;
                    }
                    
                    const [lat, lon, unixtime] = parts;
                    const latitude = parseFloat(lat.trim());
                    const longitude = parseFloat(lon.trim());
                    const timestamp = parseInt(unixtime.trim());
                    
                    if (!isNaN(latitude) && !isNaN(longitude) && !isNaN(timestamp)) {
                        // Validate coordinate ranges
                        if (latitude >= -90 && latitude <= 90 && longitude >= -180 && longitude <= 180) {
                            parsedPoints.push([latitude, longitude, timestamp]);
                        }
                    }
                }
                
                if (parsedPoints.length === 0) {
                    throw new Error('No valid data points found');
                }
                
                // Get the latest point for display
                const latestPoint = parsedPoints[parsedPoints.length - 1];
                const [latitude, longitude, timestamp] = latestPoint;
                
                console.log('Latest point:', { latitude, longitude, timestamp }); // Debug log
                
                // Update display with latest position
                document.getElementById('latitude').textContent = latitude.toFixed(6);
                document.getElementById('longitude').textContent = longitude.toFixed(6);
                document.getElementById('timestamp').textContent = unixToISO8601(timestamp);
                
                // Update map with track and latest position
                updateMapWithTrack(parsedPoints, latitude, longitude);
                
                // Update status
                updateStatus('online', 'Connected');
                lastUpdateTime = new Date();
                updateLastUpdated();
                
            } catch (error) {
                console.error('Error fetching vessel data:', error);
                updateStatus('offline', 'Connection failed');
                
                // Show error in data fields
                document.getElementById('latitude').textContent = 'Error';
                document.getElementById('longitude').textContent = 'Error';
                document.getElementById('timestamp').textContent = 'Error';
            }
        }

        // Update map with track and latest position
        function updateMapWithTrack(points, latestLat, latestLon) {
            // Remove existing track and marker
            if (trackPolyline) {
                map.removeLayer(trackPolyline);
            }
            if (vesselMarker) {
                map.removeLayer(vesselMarker);
            }
            
            // Create track polyline from all points
            const trackCoordinates = points.map(point => [point[0], point[1]]);
            
            // Create polyline with different colors for different segments
            trackPolyline = L.polyline(trackCoordinates, {
                color: '#3388ff',
                weight: 4,
                opacity: 0.8,
                smoothFactor: 1
            }).addTo(map);
            
            // Add markers for start and end points
            if (points.length > 1) {
                // Start point (oldest)
                const startPoint = points[0];
                const startMarker = L.circleMarker([startPoint[0], startPoint[1]], {
                    radius: 6,
                    fillColor: '#ff6b6b',
                    color: '#fff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(map);
                
                startMarker.bindPopup(`
                    <strong>Track Start</strong><br>
                    Lat: ${startPoint[0].toFixed(6)}<br>
                    Lon: ${startPoint[1].toFixed(6)}<br>
                    Time: ${unixToISO8601(startPoint[2])}
                `);
                
                // End point (latest) - vessel marker
                vesselMarker = L.marker([latestLat, latestLon], {
                    icon: L.divIcon({
                        className: 'vessel-marker',
                        html: 'âµ',
                        iconSize: [30, 30],
                        iconAnchor: [15, 15]
                    })
                }).addTo(map);
                
                vesselMarker.bindPopup(`
                    <strong>R/V Packard - Current Position</strong><br>
                    Lat: ${latestLat.toFixed(6)}<br>
                    Lon: ${latestLon.toFixed(6)}<br>
                    Time: ${unixToISO8601(points[points.length - 1][2])}<br>
                    <small>Track shows last ${points.length} positions</small>
                `);
            } else {
                // Single point - just show vessel marker
                vesselMarker = L.marker([latestLat, latestLon], {
                    icon: L.divIcon({
                        className: 'vessel-marker',
                        html: 'âµ',
                        iconSize: [30, 30],
                        iconAnchor: [15, 15]
                    })
                }).addTo(map);
                
                vesselMarker.bindPopup(`
                    <strong>R/V Packard</strong><br>
                    Lat: ${latestLat.toFixed(6)}<br>
                    Lon: ${latestLon.toFixed(6)}<br>
                    Time: ${unixToISO8601(points[0][2])}
                `);
            }
            
            // Fit map to show entire track with more padding for wider view
            if (points.length > 1) {
                const group = new L.featureGroup([trackPolyline, vesselMarker]);
                map.fitBounds(group.getBounds().pad(0.5));
            } else {
                map.setView([latestLat, latestLon], 6);
            }
        }

        // Update map with new position (legacy function for compatibility)
        function updateMap(lat, lon) {
            updateMapWithTrack([[lat, lon, Math.floor(Date.now() / 1000)]], lat, lon);
        }

        // Auto-refresh function
        function startAutoRefresh() {
            // Initial fetch
            fetchVesselData();
            
            // Set up interval for auto-refresh every 30 seconds
            setInterval(fetchVesselData, 30000);
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            startAutoRefresh();
        });
    </script>
</body>
</html>
